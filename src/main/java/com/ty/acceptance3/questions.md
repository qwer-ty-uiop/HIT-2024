### 如果丢包，会进入死锁状态

- 为什么会死锁？
    - 超时重传传输: 提前清理cancel的timer
    - 返回的ACK: 出现 seq 大于窗口的情况
    - 发送窗口的处理逻辑: 用的是基于偏移量的，但是移动的时候窗口中的偏移量都会改变，导致了死锁
    - 接收窗口的处理逻辑: receiveBase的逻辑有点混淆
    - 发送数据的seqNum: 逻辑混淆

### 如果未丢包，出现Timer already cancelled